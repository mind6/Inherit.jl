var documenterSearchIndex = {"docs":
[{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Inherit.jl is used to inherit fields and interface definitions from a supertype. It supports programming with an object-oriented flavor in Julia, whenever this is more appropriate than developing under traditional Julia patterns. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Fields defined in a supertype are automatically inherited by each subtype, and method declarations are checked for each subtype's implementation. An inheritance hierachy across multiple modules is supported. To accomplish this, macro processing is used to construct native Julia types, which allows the the full range of Julia syntax to be used in most situations.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\r\n\timport Inherit\r\n\tENV[\"JULIA_DEBUG\"] = \"\"\r\n\tENV[Inherit.E_SUMMARY_LEVEL] = \"info\"\r\n\t@show ENV[\"JULIA_DEBUG\"] \r\nend","category":"page"},{"location":"index.html#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Use @abstractbase to declare an abstract supertype, and use @implement to inherit from such a type. Standard struct syntax is used.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Inherit\r\n\r\n\"abstract base type of Fruity objects\"\r\n@abstractbase struct Fruit\r\n\tweight::Float64\r\n\t\"declares an interface which must be implemented\"\r\n\tfunction cost(fruit::Fruit, unitprice::Float64) end\r\nend\r\n\r\n\"\r\nconcrete type which represents an apple, inheriting from Fruit\r\nit has two fields: `weight` and `cost`\r\n\"\r\n@implement struct Apple <: Fruit \r\n\tcoresize::Int\r\nend\r\n\r\n\"implements supertype's interface declaration `cost` for the type `Apple`\"\r\nfunction cost(apple::Apple, unitprice::Float64)\r\n\tapple.weight * unitprice * (apple.coresize < 5 ? 2.0 : 1.0)\r\nend\r\n\r\nprintln(cost(Apple(3.0, 4), 1.0))\r\n\r\n# output\r\n6.0","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Note that the definition of cost function inside of Fruit is interpreted as an interface declaration; it does not result in a method being defined.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"info: Info\nWhat this declaration means is that when invoking the cost function, passing an object which is a subtype of Fruit (declared with the @implement macro) to the fruit::Fruit parameter must be able to dispatch to some method instance. This is verified when a module is first loaded. ","category":"page"},{"location":"index.html#Interaction-with-modules","page":"Introduction","title":"Interaction with modules","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Object oriented programming is most helpful when applications have grown across multiple modules. Even though Inherit.jl can be used inside scripts, its true use case is to assert common interfaces shared by different data types. Verification of method declarations takes place in the __init__() function of the module which the implementing type belongs to (i.e. where the @implement macro is used).","category":"page"},{"location":"index.html#The-module-__init__()-function","page":"Introduction","title":"The module __init__() function","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The specially named __init__() is called after the module has been fully loaded by Julia. If an interface definition has not been met, an exception will be thrown.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module M1\r\n\tusing Inherit\r\n\t@abstractbase struct Fruit\r\n\t\tweight::Float64\r\n\t\tfunction cost(fruit::Fruit, unitprice::Float64) end\r\n\tend\r\n\t@implement struct Apple <: Fruit end\r\n\t@implement struct Orange <: Fruit end\r\n\t@implement struct Kiwi <: Fruit end\r\n\tfunction cost(fruit::Union{Apple, Kiwi}, unitprice::Float64) 1.0 end\r\nend\r\n\r\n# output\r\nERROR: InitError: ImplementError: subtype M1.Orange missing Tuple{typeof(M1.cost), M1.Orange, Float64} declared as:\r\nfunction cost(fruit::Fruit, unitprice::Float64)\r\n[...]","category":"page"},{"location":"index.html#The-@postinit-macro","page":"Introduction","title":"The @postinit macro","text":"","category":"section"},{"location":"index.html#Changing-the-reporting-level","page":"Introduction","title":"Changing the reporting level","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"By default, module __init__() writes a summary message at the Info log level. You can change this by setting ENV[\"INHERIT_JL_SUMMARY_LEVEL\"] to one of [\"debug\", \"info\", \"warn\", \"error\", \"none\"].","category":"page"},{"location":"index.html#Limitations","page":"Introduction","title":"Limitations","text":"","category":"section"},{"location":"index.html#Multiple-inheritance","page":"Introduction","title":"Multiple inheritance","text":"","category":"section"},{"location":"index.html#Syntax-quirks","page":"Introduction","title":"Syntax quirks","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Use relative module reference such as ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module OtherModule\r\nend\r\n\r\nmodule MyModule\r\n\tusing ..OtherModule\r\nend","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"rather than ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module MyModule\r\n\tusing Main.OtherModule\r\nend","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":".","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Inherit.jl will not look for Main to try to find OtherModule, because parent module Main isn't available to MyModule in some situations. ","category":"page"},{"location":"index.html#@contents","page":"Introduction","title":"```@contents","text":"","category":"section"},{"location":"index.html#","page":"Introduction","title":"```","text":"","category":"section"},{"location":"index.html#@index","page":"Introduction","title":"```@index","text":"","category":"section"},{"location":"index.html#-2","page":"Introduction","title":"```","text":"","category":"section"},{"location":"index.html#@autodocs","page":"Introduction","title":"```@autodocs","text":"","category":"section"},{"location":"index.html#Modules-[Inherit]","page":"Introduction","title":"Modules = [Inherit]","text":"","category":"section"},{"location":"index.html#-3","page":"Introduction","title":"```","text":"","category":"section"}]
}
