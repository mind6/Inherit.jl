var documenterSearchIndex = {"docs":
[{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Inherit.jl is used to inherit fields and interface definitions from a supertype. It supports programming with an object-oriented flavor in Julia, whenever this is more appropriate than developing under traditional Julia patterns. ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Fields defined in a supertype are automatically inherited by each subtype, and method declarations are checked for each subtype's implementation. An inheritance hierachy across multiple modules is supported. To accomplish this, macro processing is used to construct native Julia types, which allows the the full range of Julia syntax to be used in most situations.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\r\n\timport Inherit\r\n\tENV[\"JULIA_DEBUG\"] = \"\"\r\n\tENV[Inherit.E_SUMMARY_LEVEL] = \"info\"\r\nend","category":"page"},{"location":"index.html#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Use @abstractbase to declare an abstract supertype, and use @implement to inherit from such a type. Standard struct syntax is used.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"using Inherit\r\n\r\n\"\r\nBase type of Fruity objects. \r\nCreates a julia native type with \r\n\t`abstract type Fruit end`\r\n\"\r\n@abstractbase struct Fruit\r\n\tweight::Float64\r\n\t\"declares an interface which must be implemented\"\r\n\tfunction cost(fruit::Fruit, unitprice::Float64) end\r\nend\r\n\r\n\"\r\nConcrete type which represents an apple, inheriting from Fruit.\r\nCreates a julia native type with \r\n\t`struct Apple <: Fruit weight::Float64; coresize::Int end`\r\n\"\r\n@implement struct Apple <: Fruit \r\n\tcoresize::Int\r\nend\r\n\r\n\"\r\nImplements supertype's interface declaration `cost` for the type `Apple`\r\n\"\r\nfunction cost(apple::Apple, unitprice::Float64)\r\n\tapple.weight * unitprice * (apple.coresize < 5 ? 2.0 : 1.0)\r\nend\r\n\r\nprintln(cost(Apple(3.0, 4), 1.0))\r\n\r\n# output\r\n6.0","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Note that the definition of cost function inside of Fruit is interpreted as an interface declaration; it does not result in a method being defined.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"info: Info\nWhat this declaration means is that when invoking the cost function, passing an object which is a subtype of Fruit (declared with the @implement macro) to the fruit::Fruit parameter must be able to dispatch to some method instance. This is verified when a module is first loaded. ","category":"page"},{"location":"index.html#Interaction-with-modules","page":"Introduction","title":"Interaction with modules","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Object oriented programming is most helpful when applications have grown across multiple modules. Even though Inherit.jl can be used inside scripts, its true use case is to assert common interfaces shared by different data types. Verification of method declarations takes place in the __init__() function of the module which the implementing type belongs to (i.e. where the @implement macro is used).","category":"page"},{"location":"index.html#The-module-__init__()-function","page":"Introduction","title":"The module __init__() function","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The specially named function __init__() is called after the module has been fully loaded by Julia. If an interface definition has not been met, an exception will be thrown.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module M1\r\n\tusing Inherit\r\n\t@abstractbase struct Fruit\r\n\t\tweight::Float64\r\n\t\tfunction cost(fruit::Fruit, unitprice::Float64) end\r\n\tend\r\n\t@implement struct Apple <: Fruit end\r\n\t@implement struct Orange <: Fruit end\r\n\t@implement struct Kiwi <: Fruit end\r\n\tfunction cost(fruit::Union{Apple, Kiwi}, unitprice::Float64) 1.0 end\r\nend\r\n\r\n# output\r\nERROR: InitError: ImplementError: subtype M1.Orange missing Tuple{typeof(M1.cost), M1.Orange, Float64} declared as:\r\nfunction cost(fruit::Fruit, unitprice::Float64)\r\n[...]","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Upon loading module M1, Inherit.jl throws an ImplementError from the __init__() function, telling you that it's looking for a method signature that can dispatch cost(::M1.Orange, ::Float64). It makes no complaints about Apple and Kiwi because their dispatch can be satisfied","category":"page"},{"location":"index.html#The-@postinit-macro","page":"Introduction","title":"The @postinit macro","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The presence of an @abstractbase or @implement causes Inherit.jl to generate and overwrite the module's __init__() function. To execute your own module initiation code, the @postinit macro is available. It accepts a function as argument and registers that function to be executed after __init__(). Multiple occurrences of @postinit will result in each function being called successively.","category":"page"},{"location":"index.html#Putting-it-all-together","page":"Introduction","title":"Putting it all together","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Let's demonstrate @postinit as well as other features in a more extended example.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"module M1\r\n\tusing Inherit\r\n\r\n\t@abstractbase struct Fruit\r\n\t\tweight::Float64\r\n\t\tfunction cost(fruit::Fruit, unitprice::Float64) end\r\n\tend\r\n\tfunction cost(item::Fruit, unitprice::Number)\r\n\t\tunitprice * item.weight\r\n\tend\t\t\r\nend\r\n\r\nmodule M2\r\n\tusing Inherit\r\n\timport ..M1\r\n\r\n\t@abstractbase struct Berry <: M1.Fruit\r\n\t\tfunction pack(time::Int, bunch::Dict{String, AbstractVector{<:Berry}})::Float32 end\r\n\tend\r\n\r\n\t@implement struct BlueBerry <: Berry end\r\n\tfunction pack(time::Number, bunch::Dict{String, AbstractVector{<:BlueBerry}})::Float32 end\r\n\r\nend\r\nnothing\r\n\r\n# output\r\n[ Info: Inherit.jl: processed M1 with 1 supertype having 1 method requirement. 0 subtypes were checked with 0 missing methods.\r\n[ Info: Inherit.jl: processed M2 with 1 supertype having 2 method requirements. 1 subtype was checked with 0 missing methods.","category":"page"},{"location":"index.html#Changing-the-reporting-level","page":"Introduction","title":"Changing the reporting level","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"By default, module __init__() writes a summary message at the Info log level. You can change this by setting ENV[\"INHERIT_JL_SUMMARY_LEVEL\"] to one of [\"debug\", \"info\", \"warn\", \"error\", \"none\"].","category":"page"},{"location":"index.html#Limitations","page":"Introduction","title":"Limitations","text":"","category":"section"},{"location":"index.html#Multiple-inheritance","page":"Introduction","title":"Multiple inheritance","text":"","category":"section"},{"location":"index.html#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"environment variable value description\nJULIA_DEBUG \"Inherit\" Enables printing of more detailed Debug level messsages. Default is \"\" which only prints Info level messages\nINHERIT_JL_SUMMARY_LEVEL \"debug\", \"info\", \"warn\", \"error\", or \"none\" logs the per-module summary message at the chosen level, or none at all. Default is \"info\".","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"@abstractbase\r\n@implement\r\n","category":"page"},{"location":"index.html#Inherit.@abstractbase","page":"Introduction","title":"Inherit.@abstractbase","text":"Creates a Julia abstract type, while allowing field and method declarations to be inherited by subtypes created with the @implement macro.\n\nRequires a single expression of one of following forms:\n\nstruct T ... end\nmutable struct T ... end\nstruct T <: S ... end\nmutable struct T <: S ... end\n\nSupertype S can be any valid Julia abstract type. In addition, if S was created with @abstractbase, all its fields and method declarations will be prepended to T's own definitions, and they will be inherited by any subtype of T. \n\nMutability must be the same as the supertype's mutability.\n\n\n\n\n\n","category":"macro"},{"location":"index.html#Inherit.@implement","page":"Introduction","title":"Inherit.@implement","text":"Creates a Julia struct or mutable struct type which contains all the fields of its supertype. Method interfaces declared (and inherited) by the supertype are required to be implemented.\n\nRequires a single expression of one of following forms:\n\nstruct T <: S ... end\nmutable struct T <: S ... end\n\nMutability must be the same as the supertype's mutability.\n\nMethod declarations may be from a foreign module, in which case method implementations must be added to the foreign module's function. If there is no name clash, the foreign modules's function is automatically imported into the implementing module (i.e. your current module). If there is a name clash, you must qualify the function name with the foreign module's name.\n\n\n\n\n\n","category":"macro"}]
}
