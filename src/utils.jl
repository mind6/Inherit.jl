function last_method_def(f::Function)::Method
	ms = methods(f).ms
	_, idx = findmax(m->m.primary_world, ms)
	ms[idx]
end

"converts syntax like `a.b.c.d` to AST"
function to_qualified_expr(initialargs::Symbol ...)::Union{Symbol, Expr}
	function f(curexpr::Union{Nothing, Expr}, args::Symbol ...)::Union{Symbol, Expr}
		if isempty(args)
			curexpr
		elseif length(args) == 1
			if curexpr === nothing
				args[1]
			else
				Expr(:., curexpr, QuoteNode(args[1]))
			end
		elseif length(args) > 1
			if curexpr === nothing
				f(Expr(:., args[1], QuoteNode(args[2])), args[3:end]...)
			else
				f(Expr(:., curexpr, QuoteNode(args[1])), args[2:end]...)
			end
		end
	end
	f(nothing, initialargs...)
end

"
Makes a valid `import` expression like `import modpath1.modpath2.modpath3: item`

`:(import \$modpath : \$item)` won't work even when `modpath` evaluates to `modpath1.modpath2.modpath3`
"
function to_import_expr(item::Symbol, modpath::Symbol...)::Expr
	Expr(:import, 
		Expr(:(:), 
			Expr(:., modpath...), 
			Expr(:., item)))
end

function lastsymbol(expr::Union{Symbol, Expr, QuoteNode})::Symbol
	if expr isa Symbol
		expr
	elseif expr isa QuoteNode
		expr.value
	elseif expr isa Expr
		lastsymbol(expr.args[end])
	end
end

function singular_or_plural(count::Int, singular::String, plural::Union{Missing, String}=missing)
	io = IOBuffer()
	if count == 1
		print(io, count, ' ', singular)
	else
		if plural === missing
			print(io, count, ' ', singular, 's')
		else
			print(io, count, ' ', plural)
		end
	end
	String(take!(io))
end

function tostring(modname::NTuple{N, Symbol}, typename::Symbol) where N
	io = IOBuffer()
	join(io, modname, '.')
	print(io, '.', typename)
	String(take!(io))
end

function tostring(ident::TypeIdentifier) 
	tostring(ident.modulefullname, ident.basename)
end

function getfuncname(decl::MethodDeclaration)::Symbol
	nameof(decl.sig.parameters[1].instance)
end

function getmodule(curmodule::Module, modulefullname::NTuple{N, Symbol})::Module where N
	curmod = curmodule
	for name in modulefullname
		# @show name nameof(curmod)
		# if name == nameof(curmod) return curmod end
		curmod = getproperty(curmod, name)
	end
	curmod
end

"
Creates a new module that contains (i.e. imports) only the properties of `basemodule` which are Types and Modules (i.e. excluding any functions). You can evaluate method declarations in this module to get the signature, without modifying `basemodule` itself
"
function createshadowmodule(basemodule::Module)
	newmod = Module()

	### build a list of functions and extract their types. This helps us weed out properties like Symbol("#cost") which contains the type of the `cost` function
	functypes = Set{DataType}()
	for name in names(basemodule, all=true)
		p = getproperty(basemodule, name)
		if p isa Function
			push!(functypes, typeof(p))
		end
	end
	# @show functypes

	### copy Types and Module properties from basemodule to the new module, excluding Types which are generated by function definitions.
	for name in names(basemodule, all=true)
		p = getproperty(basemodule, name)
		if p isa Union{Type, Module} && p âˆ‰ functypes
			# @show name p
			setproperty!(newmod, name, p)
		end
	end

	newmod
end

function reducetype(expr::Expr, basemodule::NTuple{N, Symbol}, basetype::Symbol, implmodule::NTuple{M, Symbol}, impltype::Symbol)::Expr where {N, M}
	MacroTools.postwalk(x->begin
		if (@capture(x, T_Symbol) && T == basetype) 	#captures the unqualified basetype by itself and reduces it
			# :($(implmodule).$(impltype))
			to_qualified_expr(implmodule..., impltype)
		elseif (@capture(x, pre_.T_) && T == basetype)	#captures a qualified basetype
			# keeps reducing the qualifiers as long as it ends with $basemodule
			idx = N
			while @capture(pre, pre2_.$(basemodule[idx]))
				if lastsymbol(pre2) != basemodule[idx]
					idx -= 1
				end
				if idx == 0 break end
				pre = pre2
			end
			if idx > 0 && pre == basemodule[idx]		# all the prefixes were consumed while matching basemodule, we're sure this is the object we want
				# :($(implmodule).$(impltype))
				to_qualified_expr(implmodule..., impltype)
			else
				x
			end
		else
			x
		end
	end, expr)
end

function make_variable_tupletype(curmodule::Module, types::Type ...)
	curmodule.eval(:(Tuple{$(types...)}))
end

function set_sig_functype(curmodule::Module, sig::Type{<:Tuple}, functype::DataType)
	@assert !isempty(sig.types)
	if length(sig.types) == 1
		sig = make_variable_tupletype(curmodule, functype)
	else
		sig = make_variable_tupletype(curmodule, functype, sig.types[2:end]...)
	end
end

"prepend __ to function name"
function privatize_funcname(funcdef::Expr)::Expr
	MacroTools.postwalk(x->begin
		if x isa Expr && x.head == :call
			x.args[1] = Symbol("__", x.args[1]) 
		end
		x
	end, funcdef)
end

isprecompiling() = ccall(:jl_generating_output, Cint, ()) == 1
